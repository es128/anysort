// Generated by CoffeeScript 1.7.1
var anymatch, anysort, generateAnysort, returnFalse, splice;

anymatch = require('anymatch');

returnFalse = function() {
  return false;
};

generateAnysort = function(criteria) {
  var matcher, sorter;
  if (criteria == null) {
    criteria = returnFalse;
  }
  matcher = anymatch.matcher(criteria);
  return sorter = function(a, b, startIndex) {
    var hasA, hasB, indexOfA, indexOfB;
    indexOfA = matcher(a, true, startIndex);
    indexOfB = matcher(b, true, startIndex);
    hasA = indexOfA !== -1;
    hasB = indexOfB !== -1;
    if (hasA && !hasB) {
      return -1;
    } else if (!hasA && hasB) {
      return 1;
    } else if (indexOfA !== indexOfB) {
      return indexOfA - indexOfB;
    } else if (hasA && hasB && indexOfA < criteria.length - 1) {
      return sorter(a, b, indexOfA + 1);
    } else if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };
};

anysort = function() {
  var a, b, criteria;
  if (arguments.length === 1) {
    return generateAnysort(arguments[0]);
  } else {
    a = arguments[0], b = arguments[1], criteria = arguments[2];
    return generateAnysort(criteria)(a, b);
  }
};

anysort.match = anymatch;

anysort.matcher = anymatch.matcher;

anysort.splice = splice = function(array, criteria, tieBreakers, suppressUnmatchedSorting) {
  var matched, matcher, unmatched;
  if (criteria == null) {
    criteria = returnFalse;
  }
  matcher = anymatch.matcher(criteria);
  matched = array.filter(matcher);
  unmatched = array.filter(function(s) {
    return -1 === matched.indexOf(s);
  });
  if (!suppressUnmatchedSorting) {
    unmatched = unmatched.sort();
  }
  if (!Array.isArray(criteria)) {
    criteria = [criteria];
  }
  matched = matched.sort(anysort([].concat.apply(criteria, tieBreakers)));
  return {
    matched: matched,
    unmatched: unmatched,
    sorted: matched.concat(unmatched)
  };
};

anysort.grouped = function(array, groups, order, suppressUnmatchedSorting) {
  var ordered, remaining, sorted, unmatchedPosition;
  if (groups == null) {
    groups = [returnFalse];
  }
  if (suppressUnmatchedSorting == null) {
    suppressUnmatchedSorting = false;
  }
  sorted = [];
  ordered = [];
  remaining = array.slice();
  unmatchedPosition = groups.indexOf('unmatched');
  groups.forEach(function(criteria, index) {
    var matched, tieBreakers, unmatched, _ref;
    if (index === unmatchedPosition) {
      return;
    }
    tieBreakers = [];
    if (index !== groups.length - 1) {
      tieBreakers = groups.slice(index + 1);
      if (index < unmatchedPosition) {
        tieBreakers.splice(unmatchedPosition - index - 1, 1);
      }
    }
    _ref = splice(remaining, criteria, tieBreakers, suppressUnmatchedSorting), matched = _ref.matched, unmatched = _ref.unmatched;
    sorted[index] = matched;
    return remaining = unmatched;
  });
  if (unmatchedPosition === -1) {
    unmatchedPosition = sorted.length;
  }
  sorted[unmatchedPosition] = remaining;
  if (Array.isArray(order)) {
    order.forEach(function(position, index) {
      return ordered[index] = sorted[position];
    });
  } else {
    ordered = sorted;
  }
  return ordered.reduce(function(flat, group) {
    return flat.concat(group);
  }, []);
};

module.exports = anysort;
